#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Descriptions to HTML Converter

This script converts the image_descriptions.txt file generated by ImageDescriber
to a formatted HTML web page with proper headings and structure.

Structure:
- Photo name as H2
- Details section as H3 with metadata in a list (only when --full is used)
- Description as H4 with the description text

By default, only the photo name and description are shown. Use --full to include
the complete details section with metadata.

Usage:
    python descriptions_to_html.py [input_file] [output_file]
    
    If no arguments provided, defaults to:
    - input: image_descriptions.txt
    - output: image_descriptions.html
"""

import argparse
import re
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional
import html
import sys

# Set UTF-8 encoding for console output on Windows
if sys.platform.startswith('win'):
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.detach())
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.detach())


class DescriptionEntry:
    """Class to represent a single image description entry"""
    
    def __init__(self):
        self.filename = ""
        self.filepath = ""
        self.photo_date = ""
        self.location = ""
        self.camera = ""
        self.settings = ""
        self.model = ""
        self.prompt_style = ""
        self.description = ""
        self.timestamp = ""
        self.raw_metadata = {}
    
    def to_html(self, include_details: bool = False) -> str:
        """Convert the entry to HTML format
        
        Args:
            include_details: Whether to include the details section with metadata
        """
        html_content = []
        
        # Photo name as H2
        html_content.append(f'<h2>{html.escape(self.filename)}</h2>')
        
        # Details section as H3 (only if include_details is True)
        if include_details:
            html_content.append('<h3>Details</h3>')
            html_content.append('<ul>')
            
            # Add metadata items to list
            if self.filepath:
                html_content.append(f'<li><strong>File Path:</strong> {html.escape(self.filepath)}</li>')
            
            if self.photo_date:
                html_content.append(f'<li><strong>Photo Date:</strong> {html.escape(self.photo_date)}</li>')
            
            if self.location:
                html_content.append(f'<li><strong>Location:</strong> {html.escape(self.location)}</li>')
            
            if self.camera:
                html_content.append(f'<li><strong>Camera:</strong> {html.escape(self.camera)}</li>')
            
            if self.settings:
                html_content.append(f'<li><strong>Settings:</strong> {html.escape(self.settings)}</li>')
            
            if self.model:
                html_content.append(f'<li><strong>Model:</strong> {html.escape(self.model)}</li>')
            
            if self.prompt_style:
                html_content.append(f'<li><strong>Prompt Style:</strong> {html.escape(self.prompt_style)}</li>')
            
            if self.timestamp:
                html_content.append(f'<li><strong>Generated:</strong> {html.escape(self.timestamp)}</li>')
            
            html_content.append('</ul>')
        
        # Description as H4
        html_content.append('<h4>Description</h4>')
        
        if self.description:
            # Convert line breaks to HTML and escape content
            description_html = html.escape(self.description).replace('\n', '<br>\n')
            html_content.append(f'<p>{description_html}</p>')
        else:
            html_content.append('<p><em>No description available</em></p>')
        
        return '\n'.join(html_content)


class DescriptionsParser:
    """Parser for image descriptions text file"""
    
    def __init__(self, input_file: Path):
        self.input_file = input_file
        self.entries: List[DescriptionEntry] = []
    
    def parse(self) -> List[DescriptionEntry]:
        """Parse the descriptions file and return a list of entries"""
        try:
            with open(self.input_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Split by separator lines (80 dashes)
            sections = re.split(r'-{80,}', content)
            
            for section in sections:
                section = section.strip()
                if not section:
                    continue
                
                # Check if this section contains the header
                if section.startswith('Image Descriptions') or section.startswith('='):
                    # This section might contain both header and first entry
                    # Look for the actual entry part after the header
                    lines = section.split('\n')
                    entry_start = -1
                    
                    # Find where the entry starts (look for "File:" line)
                    for i, line in enumerate(lines):
                        if line.strip().startswith('File:'):
                            entry_start = i
                            break
                    
                    if entry_start != -1:
                        # Extract just the entry part
                        entry_lines = lines[entry_start:]
                        entry_section = '\n'.join(entry_lines)
                        entry = self._parse_section(entry_section)
                        if entry and entry.filename:
                            self.entries.append(entry)
                    continue
                
                # Regular entry section
                entry = self._parse_section(section)
                if entry and entry.filename:
                    self.entries.append(entry)
            
            return self.entries
            
        except Exception as e:
            print(f"Error parsing file: {e}")
            return []
    
    def _parse_section(self, section: str) -> Optional[DescriptionEntry]:
        """Parse a single section into a DescriptionEntry"""
        entry = DescriptionEntry()
        lines = section.split('\n')
        
        description_started = False
        description_lines = []
        
        for line in lines:
            line = line.strip()
            if not line:
                continue
            
            # Check if we've reached the description
            if line.startswith('Description:'):
                description_started = True
                desc_text = line[12:].strip()  # Remove 'Description: '
                if desc_text:
                    description_lines.append(desc_text)
                continue
            
            # If we're in description mode, collect all remaining lines
            if description_started:
                if line.startswith('Timestamp:'):
                    # End of description, parse timestamp
                    entry.timestamp = line[10:].strip()
                    break
                else:
                    description_lines.append(line)
                continue
            
            # Parse metadata fields
            if line.startswith('File:'):
                entry.filename = line[5:].strip()
            elif line.startswith('Path:'):
                entry.filepath = line[5:].strip()
            elif line.startswith('Photo Date:'):
                entry.photo_date = line[11:].strip()
            elif line.startswith('Location:'):
                entry.location = line[9:].strip()
            elif line.startswith('Camera:'):
                entry.camera = line[7:].strip()
            elif line.startswith('Settings:'):
                entry.settings = line[9:].strip()
            elif line.startswith('Model:'):
                entry.model = line[6:].strip()
            elif line.startswith('Prompt Style:'):
                entry.prompt_style = line[13:].strip()
            elif line.startswith('Timestamp:'):
                entry.timestamp = line[10:].strip()
        
        # Join description lines
        entry.description = '\n'.join(description_lines).strip()
        
        return entry


class HTMLGenerator:
    """Generator for HTML output"""
    
    def __init__(self, entries: List[DescriptionEntry], title: str = "Image Descriptions", include_details: bool = False):
        self.entries = entries
        self.title = title
        self.include_details = include_details
    
    def generate(self) -> str:
        """Generate complete HTML document"""
        html_parts = []
        
        # HTML header
        html_parts.append(self._generate_header())
        
        # Body content
        html_parts.append('<body>')
        html_parts.append(f'<div class="container">')
        html_parts.append(f'<h1>{html.escape(self.title)}</h1>')
        
        # Generation info
        html_parts.append(f'<p class="generation-info">Generated on {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>')
        html_parts.append(f'<p class="stats">Total images: {len(self.entries)}</p>')
        
        # Table of contents
        if len(self.entries) > 5:
            html_parts.append(self._generate_toc())
        
        # Individual entries
        for i, entry in enumerate(self.entries):
            html_parts.append(f'<div class="entry" id="entry-{i}">')
            html_parts.append(entry.to_html(include_details=self.include_details))
            html_parts.append('</div>')
            
            # Add separator between entries
            if i < len(self.entries) - 1:
                html_parts.append('<hr class="entry-separator">')
        
        html_parts.append('</div>')
        html_parts.append('</body>')
        html_parts.append('</html>')
        
        return '\n'.join(html_parts)
    
    def _generate_header(self) -> str:
        """Generate HTML header with CSS styling"""
        return f'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{html.escape(self.title)}</title>
    <style>
        body {{
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #212529;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }}
        
        .container {{
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        
        h1 {{
            color: #1a1a1a;
            border-bottom: 3px solid #0056b3;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }}
        
        h2 {{
            color: #0056b3;
            margin-top: 40px;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-left: 4px solid #0056b3;
            padding-left: 15px;
        }}
        
        h3 {{
            color: #155724;
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }}
        
        h4 {{
            color: #6f42c1;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }}
        
        .generation-info {{
            color: #495057;
            font-style: italic;
            margin-bottom: 10px;
        }}
        
        .stats {{
            color: #495057;
            font-weight: bold;
            margin-bottom: 30px;
        }}
        
        .entry {{
            margin-bottom: 40px;
        }}
        
        .entry-separator {{
            border: none;
            border-top: 2px solid #dee2e6;
            margin: 30px 0;
        }}
        
        ul {{
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px 20px;
            margin: 10px 0;
        }}
        
        li {{
            margin-bottom: 5px;
        }}
        
        li strong {{
            color: #1a1a1a;
        }}
        
        p {{
            margin-bottom: 15px;
            text-align: justify;
        }}
        
        .toc {{
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0 40px 0;
        }}
        
        .toc h3 {{
            margin-top: 0;
            color: #1a1a1a;
        }}
        
        .toc ul {{
            background-color: transparent;
            border: none;
            padding: 0;
            margin: 0;
        }}
        
        .toc li {{
            margin-bottom: 8px;
        }}
        
        .toc a {{
            color: #0056b3;
            text-decoration: none;
        }}
        
        .toc a:hover {{
            text-decoration: underline;
            color: #004085;
        }}
        
        .toc a:focus {{
            outline: 2px solid #0056b3;
            outline-offset: 2px;
        }}
        
        @media (max-width: 768px) {{
            body {{
                padding: 10px;
            }}
            
            .container {{
                padding: 20px;
            }}
            
            h1 {{
                font-size: 1.8em;
            }}
            
            h2 {{
                font-size: 1.3em;
            }}
        }}
    </style>
</head>'''
    
    def _generate_toc(self) -> str:
        """Generate table of contents"""
        toc_items = []
        
        for i, entry in enumerate(self.entries):
            toc_items.append(f'<li><a href="#entry-{i}">{html.escape(entry.filename)}</a></li>')
        
        return f'''<div class="toc">
    <h3>Table of Contents</h3>
    <ul>
        {chr(10).join(toc_items)}
    </ul>
</div>'''


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Convert image descriptions text file to HTML format",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python descriptions_to_html.py
    python descriptions_to_html.py image_descriptions.txt
    python descriptions_to_html.py input.txt output.html
    python descriptions_to_html.py --title "My Photo Collection" image_descriptions.txt
    python descriptions_to_html.py --full image_descriptions.txt
    python descriptions_to_html.py --full --title "Complete Photo Gallery" image_descriptions.txt
        """
    )
    
    parser.add_argument(
        "input_file",
        nargs="?",
        default="image_descriptions.txt",
        help="Input text file with image descriptions (default: image_descriptions.txt)"
    )
    
    parser.add_argument(
        "output_file",
        nargs="?",
        default=None,
        help="Output HTML file (default: input_file with .html extension)"
    )
    
    parser.add_argument(
        "--title",
        default="Image Descriptions",
        help="Title for the HTML page (default: 'Image Descriptions')"
    )
    
    parser.add_argument(
        "--full",
        action="store_true",
        help="Include full details section with metadata for each image (default: description only)"
    )
    
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    args = parser.parse_args()
    
    # Set up file paths
    input_path = Path(args.input_file)
    
    if args.output_file:
        output_path = Path(args.output_file)
    else:
        # Use workflow output directory by default
        try:
            from workflow_utils import WorkflowConfig
            config = WorkflowConfig()
            workflow_output_dir = config.get_step_output_dir("html_reports", create=True)
            output_path = workflow_output_dir / "image_descriptions.html"
            if args.verbose:
                print(f"Using workflow output directory: {workflow_output_dir}")
        except ImportError:
            # workflow_utils not available, use default
            output_path = input_path.with_suffix('.html')
    
    # Check if input file exists
    if not input_path.exists():
        print(f"Error: Input file '{input_path}' not found")
        return 1
    
    if args.verbose:
        print(f"Input file: {input_path}")
        print(f"Output file: {output_path}")
        print(f"Title: {args.title}")
        print(f"Include details: {args.full}")
    
    # Parse the descriptions file
    parser = DescriptionsParser(input_path)
    entries = parser.parse()
    
    if not entries:
        print("No entries found in the input file")
        return 1
    
    if args.verbose:
        print(f"Parsed {len(entries)} entries")
    
    # Generate HTML
    generator = HTMLGenerator(entries, args.title, include_details=args.full)
    html_content = generator.generate()
    
    # Write output file
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        print(f"Successfully generated HTML file: {output_path}")
        print(f"Processed {len(entries)} image descriptions")
        
        # Show some statistics
        entries_with_metadata = sum(1 for entry in entries if entry.photo_date or entry.location or entry.camera)
        print(f"Entries with metadata: {entries_with_metadata}")
        
        return 0
        
    except Exception as e:
        print(f"Error writing output file: {e}")
        return 1


if __name__ == "__main__":
    exit(main())
